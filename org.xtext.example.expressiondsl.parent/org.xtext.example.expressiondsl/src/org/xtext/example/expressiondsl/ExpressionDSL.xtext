grammar org.xtext.example.expressiondsl.ExpressionDSL with org.eclipse.xtext.common.Terminals

generate expressionDSL "http://www.xtext.org/example/expressiondsl/ExpressionDSL"

Model:
	statements+=Statement*;

Statement:
	VariableDef				|
	ConstDef				|
	StructDef				|
	FunctionDef				|
	FunctionCallStatement	|
	VariableAssignment
;

VariableDef:
	'var' type=TYPE name=ValidID (options=Dim)? ';'
;

ConstDef:
	'val' type=TYPE name=ValidID (options=Dim)? ';'
;

StructDef:
	'struct' name=ValidID (options=Dim)? ';'
	subFields+=(SubField)*
	'endstruct' ';'
;

SubFieldDef:
	('subf')? type=TYPE name=ValidID (options=Dim)? ';' 
;

SubField:
	SubFieldDef | StructDef
;

FunctionDef:
	'def' type=TYPE name=ValidID ';'
;

VariableAssignment:
//  The assignment operators are:
//	-->	  = The expression is assigned to the target
//	-->	 += The expression is added to the target
//	-->	 -= The expression is subtracted from the target
//	-->  *= The target is multiplied by the expression
//	-->	 /= The target is divided by the expression
//	-->	**= The target is assigned the target raised to the power of the expression
	tgtvar=[VariableDef]
	op=('=' | '+=' | '-=' | '*=' | '/=' | '**=' )
	exp=Expression ';'
;

FunctionCallStatement:
	'call'? call=FunctionCall ";"
;

FunctionCall:
	=> ref=[FunctionDef]
	('('
 		(params+=Expression (':' params+=Expression)*)?
 	')')
;

// ArrayExpOption1
//ArrayExp returns Expression:
//	Primary (
//		=> ( {ArrayExp.left=current} '(' arrayDimensions=Expression ')' )
//	)?
//;

//ArrayExpOption2
//ArrayExp:
//	=> ref=[Variable] '(' index=Expression ')'
//;

//ArrayExpOption3
//	https://www.eclipse.org/forums/index.php/t/503752/
//ArrayExp:
//	VariableArray	|
//	StructArray		|
//	SubFieldArray
//;
//VariableArray returns ArrayExp:
//	{VariableArray} => ref=[VariableDef] '(' arrayDimensions=Expression ')'
//;
//StructArray returns ArrayExp:
//	{StructArray} => ref=[StructDef] '(' arrayDimensions=Expression ')'
//;
//SubFieldArray returns ArrayExp:
//	{SubFieldArray} => ref=[SubFieldDef] '(' arrayDimensions=Expression ')'
//;

//ArrayExpOption4:
//ArrayExp:
//	ref=[Variable|ValidID]
//	'(' arrayDimensions=Expression ')'
//;

//ArrayExpOption5:
ParmSEP:
	':'
;
QualSEP:
	'.'
;
VariableOrArrayOrFunc:
	ref=[Named|ValidID]
	( '(' //Optional '()'
		(  //Optional Parameter '(params)'
			params+=Expression (ParmSEP params+=Expression)* //One or More optional Parameters '(params1:params2)'
		)?
	')')?
;
QualifiedRef:
	VariableOrArrayOrFunc ({QualifiedRefX.head=current} QualSEP tail=VariableOrArrayOrFunc)*
;

//DotExpression returns Ref:
//	StructArray ({DotExpression.ref=current}  "." (tail=[SubFieldArray] | tail=[StructArray]) )*
//;
//--------------------------------------------------------------------------
/* Expressions Precedence: 
 * 	--> ()
 * 	--> Built-in functions, user-defined functions
 * 	--> unary +, unary -, NOT
 * 	--> **
 * 	--> *, /
 * 	--> binary +, binary -
 * 	--> =, <>, >, >=, <, <=
 * 	--> AND
 * 	--> OR
 * 
 *  https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions
 *  IntroductionToExpressionLanguagesWithXtext
 *  	PDF - https://www.eclipsecon.org/france2017/sites/default/files/slides/IntroductionToExpressionLanguagesWithXtext.pdf
 * 		Vid - https://www.youtube.com/watch?v=fnPxkWqo_R8
 *	https://www.eclipse.org/forums/index.php/t/503752/
 ***/
Expression: Or;
Or returns Expression:
	And (
		{Or.left=current} 'OR'
		right=And
	)*;
And returns Expression:
	Comparison (
		{And.left=current} 'AND'
		right=Comparison
	)*;
Comparison returns Expression: // Relational
	BinaryPlusOrMinus (
		{Comparison.left=current} op=('=' | '<>' | '>=' | '<=' | '>' | '<')
		right=BinaryPlusOrMinus
	)*;
BinaryPlusOrMinus returns Expression:
	MulOrDiv (
		({BinaryPlus.left=current} '+' | {BinaryMinus.left=current} '-')
		right=MulOrDiv
	)*;
MulOrDiv returns Expression:
	Exponent (
		({MulOrDiv.left=current} op=('*' | '/'))
		right=Exponent
	)*;
Exponent returns Expression:
	//  https://www.eclipse.org/Xtext/documentation/307_special_languages.html#expressions
	//	http://blog.efftinge.de/2010/08/parsing-expressions-with-xtext.html
	//	Right associativity is done using the following pattern (note the quantity operator and the call to the rule itself at the end)
	// '*' - Left Associativity
	// '?' - Right Associativity
	UnaryPlusMinusOrNot (
		{Exponent.left=current} '**'
		right=Exponent
	)?;
UnaryPlusMinusOrNot returns Expression:
	// https://dslmeinte.wordpress.com/2011/03/21/pre-and-postfix-operators-in-xtext/
	// https://dslmeinte.wordpress.com/2011/03/24/more-on-pre-and-postfix-operators-in-xtext/
	FunctionExp	|
	( ({UnaryPlus} '+' | {UnaryMinus} '-' | {Not} 'NOT') expr=UnaryPlusMinusOrNot )
	;
FunctionExp returns Expression:
//	ArrayExp	|
//  FunctionCall
	QualifiedRef |
	Primary
	;
Primary returns Expression:
//	DotExpression		|
//	ArrayExp			|
//	VariableRef			|
//	QualifiedName		|
	'(' Expression ')'	|
	Atomic
	;
Atomic returns Expression:
	{IntConstant} value=INT			|
	{StringConstant} value=STRING	|
	{BooleanConstant} value=BOOL
	;
//--------------------------------------------------------------------------
//VariableOrConstRef:
//	VariableDef	|
//	ConstDef	|
//	StructDef	|
//	SubField
//;

//Variable:
//	VariableDef	|
//	StructDef	|
//	SubField
//;


Dim:
//Dimensions of Array (as in how many elements)
	'DIM' '(' arrayDimensions=INT ')'
;

//--------------------------------------------------------------------------
// Helper 
// https://dslmeinte.wordpress.com/2014/09/11/ambiguitiy-in-xtext-grammars-part-2/
Named: 
	VariableDef	|
	ConstDef	|
	StructDef	|
	SubFieldDef	|
	FunctionDef
;

ValidID:
	ID
;

//QualifiedName:
//	ArrayExp ({ArrayExp.left=current} '.' tail=ArrayExp)*
//;

terminal TYPE:
	'int' | 'char' | 'bool'
;
terminal BOOL:
	'true' | 'false'
;